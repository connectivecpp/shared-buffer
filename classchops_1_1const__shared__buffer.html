<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shared Buffer: chops::const_shared_buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Shared Buffer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classchops_1_1const__shared__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chops::const_shared_buffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A reference counted non-modifiable buffer class with various convenience methods, providing efficient copying and convenient buffer lifetime management.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="shared__buffer_8hpp_source.html">shared_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a624e8f7ac0c0080ac6fca5d4be5d0eb1" id="r_a624e8f7ac0c0080ac6fca5d4be5d0eb1"><td class="memItemLeft" align="right" valign="top"><a id="a624e8f7ac0c0080ac6fca5d4be5d0eb1" name="a624e8f7ac0c0080ac6fca5d4be5d0eb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte_vec</b> = std::vector&lt;std::byte&gt;</td></tr>
<tr class="separator:a624e8f7ac0c0080ac6fca5d4be5d0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc59c6b9668b04364e38ad84d085c622" id="r_afc59c6b9668b04364e38ad84d085c622"><td class="memItemLeft" align="right" valign="top"><a id="afc59c6b9668b04364e38ad84d085c622" name="afc59c6b9668b04364e38ad84d085c622"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename byte_vec::size_type</td></tr>
<tr class="separator:afc59c6b9668b04364e38ad84d085c622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad985cccb5f3e51a085235842b2abd597" id="r_ad985cccb5f3e51a085235842b2abd597"><td class="memItemLeft" align="right" valign="top"><a id="ad985cccb5f3e51a085235842b2abd597" name="ad985cccb5f3e51a085235842b2abd597"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>const_shared_buffer</b> (const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;)=default</td></tr>
<tr class="separator:ad985cccb5f3e51a085235842b2abd597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8d9da23f05c1b0c25f5b5547866c9" id="r_a46c8d9da23f05c1b0c25f5b5547866c9"><td class="memItemLeft" align="right" valign="top"><a id="a46c8d9da23f05c1b0c25f5b5547866c9" name="a46c8d9da23f05c1b0c25f5b5547866c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>const_shared_buffer</b> (<a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a46c8d9da23f05c1b0c25f5b5547866c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452884e2ae08193babd48dc569a118a" id="r_ab452884e2ae08193babd48dc569a118a"><td class="memItemLeft" align="right" valign="top"><a id="ab452884e2ae08193babd48dc569a118a" name="ab452884e2ae08193babd48dc569a118a"></a>
<a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;)=delete</td></tr>
<tr class="separator:ab452884e2ae08193babd48dc569a118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa203488dceea59d722ce84ad3cb822aa" id="r_aa203488dceea59d722ce84ad3cb822aa"><td class="memItemLeft" align="right" valign="top"><a id="aa203488dceea59d722ce84ad3cb822aa" name="aa203488dceea59d722ce84ad3cb822aa"></a>
<a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aa203488dceea59d722ce84ad3cb822aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d791f62d01167f040e08e35c6a1076b" id="r_a1d791f62d01167f040e08e35c6a1076b"><td class="memTemplParams" colspan="2">template&lt;std::size_t Ext&gt; </td></tr>
<tr class="memitem:a1d791f62d01167f040e08e35c6a1076b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d791f62d01167f040e08e35c6a1076b">const_shared_buffer</a> (std::span&lt; const std::byte, Ext &gt; sp)</td></tr>
<tr class="memdesc:a1d791f62d01167f040e08e35c6a1076b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying from a <code>std::span</code> of <code>std::byte</code>.  <br /></td></tr>
<tr class="separator:a1d791f62d01167f040e08e35c6a1076b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce416e4c75d7516fe83ad70b26a6ef2" id="r_a6ce416e4c75d7516fe83ad70b26a6ef2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce416e4c75d7516fe83ad70b26a6ef2">const_shared_buffer</a> (const std::byte *buf, std::size_t sz)</td></tr>
<tr class="memdesc:a6ce416e4c75d7516fe83ad70b26a6ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying from a <code>std::byte</code> array.  <br /></td></tr>
<tr class="separator:a6ce416e4c75d7516fe83ad70b26a6ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c01c207166965d164e3bf6ae6618f4" id="r_a01c01c207166965d164e3bf6ae6618f4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t Ext&gt; </td></tr>
<tr class="memitem:a01c01c207166965d164e3bf6ae6618f4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01c01c207166965d164e3bf6ae6618f4">const_shared_buffer</a> (std::span&lt; const T, Ext &gt; sp)</td></tr>
<tr class="memdesc:a01c01c207166965d164e3bf6ae6618f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying from a <code>std::span</code>.  <br /></td></tr>
<tr class="separator:a01c01c207166965d164e3bf6ae6618f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3e6f7c92f142f75521463d58eefdb9" id="r_aff3e6f7c92f142f75521463d58eefdb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff3e6f7c92f142f75521463d58eefdb9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff3e6f7c92f142f75521463d58eefdb9">const_shared_buffer</a> (const T *buf, std::size_t num)</td></tr>
<tr class="memdesc:aff3e6f7c92f142f75521463d58eefdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying bytes from an arbitrary pointer.  <br /></td></tr>
<tr class="separator:aff3e6f7c92f142f75521463d58eefdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf148d6958a787d3a281d3b20540f3da" id="r_abf148d6958a787d3a281d3b20540f3da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf148d6958a787d3a281d3b20540f3da">const_shared_buffer</a> (const void *buf, size_type sz)</td></tr>
<tr class="memdesc:abf148d6958a787d3a281d3b20540f3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying bytes from a void pointer.  <br /></td></tr>
<tr class="separator:abf148d6958a787d3a281d3b20540f3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4866e237f420e57952a0a3a4f5e64df5" id="r_a4866e237f420e57952a0a3a4f5e64df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4866e237f420e57952a0a3a4f5e64df5">const_shared_buffer</a> (const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4866e237f420e57952a0a3a4f5e64df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by copying from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object.  <br /></td></tr>
<tr class="separator:a4866e237f420e57952a0a3a4f5e64df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42868a259f0a7761276ac54a84a8b515" id="r_a42868a259f0a7761276ac54a84a8b515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42868a259f0a7761276ac54a84a8b515">const_shared_buffer</a> (<a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a42868a259f0a7761276ac54a84a8b515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by moving from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object.  <br /></td></tr>
<tr class="separator:a42868a259f0a7761276ac54a84a8b515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45adf8854f06828ae2fcbffe3a0c4c" id="r_a9f45adf8854f06828ae2fcbffe3a0c4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f45adf8854f06828ae2fcbffe3a0c4c">const_shared_buffer</a> (byte_vec &amp;&amp;bv) noexcept</td></tr>
<tr class="memdesc:a9f45adf8854f06828ae2fcbffe3a0c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct from a <code>std::vector</code> of <code>std::bytes</code>.  <br /></td></tr>
<tr class="separator:a9f45adf8854f06828ae2fcbffe3a0c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbaaf545d1b1c1619fad8a541722da8" id="r_a6cbaaf545d1b1c1619fad8a541722da8"><td class="memTemplParams" colspan="2">template&lt;typename InIt &gt; </td></tr>
<tr class="memitem:a6cbaaf545d1b1c1619fad8a541722da8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6cbaaf545d1b1c1619fad8a541722da8">const_shared_buffer</a> (InIt beg, InIt end)</td></tr>
<tr class="memdesc:a6cbaaf545d1b1c1619fad8a541722da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from input iterators.  <br /></td></tr>
<tr class="separator:a6cbaaf545d1b1c1619fad8a541722da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe526ffac6042397d7f7dc5b3428e1a" id="r_abfe526ffac6042397d7f7dc5b3428e1a"><td class="memItemLeft" align="right" valign="top">const std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfe526ffac6042397d7f7dc5b3428e1a">data</a> () const noexcept</td></tr>
<tr class="memdesc:abfe526ffac6042397d7f7dc5b3428e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>const</code> <code>std::byte</code> pointer to beginning of buffer.  <br /></td></tr>
<tr class="separator:abfe526ffac6042397d7f7dc5b3428e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592486ed76781c38376a1c91dcb307a8" id="r_a592486ed76781c38376a1c91dcb307a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a592486ed76781c38376a1c91dcb307a8">size</a> () const noexcept</td></tr>
<tr class="memdesc:a592486ed76781c38376a1c91dcb307a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size (number of bytes) of buffer.  <br /></td></tr>
<tr class="separator:a592486ed76781c38376a1c91dcb307a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44551e028686d7d8e2f272828d5b47fa" id="r_a44551e028686d7d8e2f272828d5b47fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44551e028686d7d8e2f272828d5b47fa">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a44551e028686d7d8e2f272828d5b47fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if size is zero.  <br /></td></tr>
<tr class="separator:a44551e028686d7d8e2f272828d5b47fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c573c86e09b9f47bb5ee114eda2c0c" id="r_a02c573c86e09b9f47bb5ee114eda2c0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c573c86e09b9f47bb5ee114eda2c0c">operator==</a> (const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a02c573c86e09b9f47bb5ee114eda2c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> objects for internal buffer byte-by-byte equality.  <br /></td></tr>
<tr class="separator:a02c573c86e09b9f47bb5ee114eda2c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbc786e8c60d13f2202b835722e3c0b" id="r_a3dbc786e8c60d13f2202b835722e3c0b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dbc786e8c60d13f2202b835722e3c0b">operator&lt;=&gt;</a> (const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a3dbc786e8c60d13f2202b835722e3c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> objects for internal buffer byte-by-byte spaceship operator ordering.  <br /></td></tr>
<tr class="separator:a3dbc786e8c60d13f2202b835722e3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a405446ef167d52348b9b82f7f9348e9d" id="r_a405446ef167d52348b9b82f7f9348e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a405446ef167d52348b9b82f7f9348e9d">operator==</a> (const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;lhs, const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:a405446ef167d52348b9b82f7f9348e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object with a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> for internal buffer byte-by-byte equality.  <br /></td></tr>
<tr class="separator:a405446ef167d52348b9b82f7f9348e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2cd63ccdaaf59bbdc0fa8a0903ef16" id="r_a7f2cd63ccdaaf59bbdc0fa8a0903ef16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f2cd63ccdaaf59bbdc0fa8a0903ef16">operator==</a> (const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;lhs, const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7f2cd63ccdaaf59bbdc0fa8a0903ef16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> object with a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> for internal buffer byte-by-byte equality.  <br /></td></tr>
<tr class="separator:a7f2cd63ccdaaf59bbdc0fa8a0903ef16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A reference counted non-modifiable buffer class with various convenience methods, providing efficient copying and convenient buffer lifetime management. </p>
<p>The primary difference between this class and the <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> class is that once a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> object is constructed, nothing inside it can be modified. This allows it to be used with asynchronous IO functions which depend on the buffer staying the same (i.e. the internal pointer to the data and the size) for the full lifetime of the asynchronous operations.</p>
<dl class="section invariant"><dt>Invariant</dt><dd>There will always be an internal buffer of data, even if the size is zero. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d791f62d01167f040e08e35c6a1076b" name="a1d791f62d01167f040e08e35c6a1076b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d791f62d01167f040e08e35c6a1076b">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte, Ext &gt;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying from a <code>std::span</code> of <code>std::byte</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td><code>std::byte</code> span pointing to buffer of data. The data is copied into the internal buffer of the <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ce416e4c75d7516fe83ad70b26a6ef2" name="a6ce416e4c75d7516fe83ad70b26a6ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce416e4c75d7516fe83ad70b26a6ef2">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">const std::byte *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying from a <code>std::byte</code> array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Size cannot be greater than the source buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Non-null pointer to <code>std::byte</code> buffer of data. The data is copied into the internal buffer of the <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code>.</td></tr>
    <tr><td class="paramname">sz</td><td>Size of buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01c01c207166965d164e3bf6ae6618f4" name="a01c01c207166965d164e3bf6ae6618f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c01c207166965d164e3bf6ae6618f4">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t Ext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const T, Ext &gt;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying from a <code>std::span</code>. </p>
<p>The type of the span must be convertible to or be layout compatible with <code>std::byte</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td><code>std::span</code> pointing to buffer of data. The <code>std::span</code> pointer is cast into a <code>std::byte</code> pointer and bytes are then copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff3e6f7c92f142f75521463d58eefdb9" name="aff3e6f7c92f142f75521463d58eefdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3e6f7c92f142f75521463d58eefdb9">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying bytes from an arbitrary pointer. </p>
<p>The pointer passed into this constructor is cast into a <code>std::byte</code> pointer and bytes are then copied. In particular, this method can be used for <code>char</code> pointers, <code>unsigned</code> <code>char</code> pointers, <code>std::uint8_t</code> pointers, etc. Non character types that are trivially copyable are also allowed, although the usual care must be taken (padding bytes, alignment, etc).</p>
<p>The type of the span must be convertible to or be layout compatible with <code>std::byte</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Size cannot be greater than the source buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Non-null pointer to an array of data.</td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf148d6958a787d3a281d3b20540f3da" name="abf148d6958a787d3a281d3b20540f3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf148d6958a787d3a281d3b20540f3da">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying bytes from a void pointer. </p>
<p>The pointer passed into this constructor is cast into a <code>std::byte</code> pointer and bytes are then copied.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Size cannot be greater than the source buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Non-null <code>void</code> pointer to a buffer of data.</td></tr>
    <tr><td class="paramname">sz</td><td>Size of buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4866e237f420e57952a0a3a4f5e64df5" name="a4866e237f420e57952a0a3a4f5e64df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4866e237f420e57952a0a3a4f5e64df5">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by copying from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object. </p>
<p>This constructor will copy from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code>. There is an alternative constructor that is more efficient which moves from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> instead of copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> containing bytes to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42868a259f0a7761276ac54a84a8b515" name="a42868a259f0a7761276ac54a84a8b515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42868a259f0a7761276ac54a84a8b515">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct by moving from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object. </p>
<p>This constructor will move from a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> into a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code>. This allows efficient API boundaries, where application code can construct and fill in a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code>, then use this constructor which will <code>std::move</code> it into a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> for use with asynchronous functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> to be moved from; after moving the <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> will be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f45adf8854f06828ae2fcbffe3a0c4c" name="a9f45adf8854f06828ae2fcbffe3a0c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f45adf8854f06828ae2fcbffe3a0c4c">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">byte_vec &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>bv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct from a <code>std::vector</code> of <code>std::bytes</code>. </p>
<p>Efficiently construct from a <code>std::vector</code> of <code>std::bytes</code> by moving into a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code>. </p>

</div>
</div>
<a id="a6cbaaf545d1b1c1619fad8a541722da8" name="a6cbaaf545d1b1c1619fad8a541722da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbaaf545d1b1c1619fad8a541722da8">&#9670;&#160;</a></span>const_shared_buffer() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chops::const_shared_buffer::const_shared_buffer </td>
          <td>(</td>
          <td class="paramtype">InIt</td>          <td class="paramname"><span class="paramname"><em>beg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIt</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from input iterators. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Valid iterator range, where each element is convertible to a <code>std::byte</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Beginning input iterator of range. </td></tr>
    <tr><td class="paramname">end</td><td>Ending input iterator of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abfe526ffac6042397d7f7dc5b3428e1a" name="abfe526ffac6042397d7f7dc5b3428e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe526ffac6042397d7f7dc5b3428e1a">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::byte * chops::const_shared_buffer::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>const</code> <code>std::byte</code> pointer to beginning of buffer. </p>
<p>This method provides pointer access to the beginning of the buffer. If the buffer is empty the pointer cannot be dereferenced or undefined behavior will occur.</p>
<p>Accessing past the end of the internal buffer (as defined by the <code><a class="el" href="#a592486ed76781c38376a1c91dcb307a8" title="Return size (number of bytes) of buffer.">size()</a></code> method) results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const</code> <code>std::byte</code> pointer to buffer. </dd></dl>

</div>
</div>
<a id="a44551e028686d7d8e2f272828d5b47fa" name="a44551e028686d7d8e2f272828d5b47fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44551e028686d7d8e2f272828d5b47fa">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool chops::const_shared_buffer::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query to see if size is zero. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if empty (size equals zero). </dd></dl>

</div>
</div>
<a id="a3dbc786e8c60d13f2202b835722e3c0b" name="a3dbc786e8c60d13f2202b835722e3c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbc786e8c60d13f2202b835722e3c0b">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto chops::const_shared_buffer::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> objects for internal buffer byte-by-byte spaceship operator ordering. </p>
<p>Internally this invokes the <code>std::vector</code> <code>&lt;=&gt;</code> on <code>std::byte</code> elements.</p>
<dl class="section return"><dt>Returns</dt><dd>Spaceship operator comparison result. </dd></dl>

</div>
</div>
<a id="a02c573c86e09b9f47bb5ee114eda2c0c" name="a02c573c86e09b9f47bb5ee114eda2c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c573c86e09b9f47bb5ee114eda2c0c">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool chops::const_shared_buffer::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> objects for internal buffer byte-by-byte equality. </p>
<p>Internally this invokes the <code>std::vector</code> <code>operator==</code> on <code>std::byte</code> elements.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code><a class="el" href="#a592486ed76781c38376a1c91dcb307a8" title="Return size (number of bytes) of buffer.">size()</a></code> same for each, and each byte compares <code>true</code>. </dd></dl>

</div>
</div>
<a id="a592486ed76781c38376a1c91dcb307a8" name="a592486ed76781c38376a1c91dcb307a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592486ed76781c38376a1c91dcb307a8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type chops::const_shared_buffer::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size (number of bytes) of buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of buffer, which may be zero. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a7f2cd63ccdaaf59bbdc0fa8a0903ef16" name="a7f2cd63ccdaaf59bbdc0fa8a0903ef16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2cd63ccdaaf59bbdc0fa8a0903ef16">&#9670;&#160;</a></span>operator== <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> object with a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> for internal buffer byte-by-byte equality. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code><a class="el" href="#a592486ed76781c38376a1c91dcb307a8" title="Return size (number of bytes) of buffer.">size()</a></code> same for each, and each byte compares <code>true</code>. </dd></dl>

</div>
</div>
<a id="a405446ef167d52348b9b82f7f9348e9d" name="a405446ef167d52348b9b82f7f9348e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405446ef167d52348b9b82f7f9348e9d">&#9670;&#160;</a></span>operator== <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1mutable__shared__buffer.html">mutable_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchops_1_1const__shared__buffer.html">const_shared_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a <code><a class="el" href="classchops_1_1mutable__shared__buffer.html" title="A mutable (modifiable) byte buffer class with convenience methods, internally reference-counted for e...">mutable_shared_buffer</a></code> object with a <code><a class="el" href="classchops_1_1const__shared__buffer.html" title="A reference counted non-modifiable buffer class with various convenience methods, providing efficient...">const_shared_buffer</a></code> for internal buffer byte-by-byte equality. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code><a class="el" href="#a592486ed76781c38376a1c91dcb307a8" title="Return size (number of bytes) of buffer.">size()</a></code> same for each, and each byte compares <code>true</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/buffer/<a class="el" href="shared__buffer_8hpp_source.html">shared_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
